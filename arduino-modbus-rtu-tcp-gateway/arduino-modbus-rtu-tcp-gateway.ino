#include <ArduinoRS485.h>


#include <CircularBuffer.h>
#include <StreamLib.h>
#include <WiFi.h>

#define SCAN_REQUEST 0xFE 
#define mySerial Serial2   
#define DEBUG  1        

#ifdef DEBUG
#define dbg(x...) Serial.print(x);
#define dbgln(x...) Serial.println(x);
#else /* DEBUG */
#define dbg(x...) ;
#define dbgln(x...) ;
#endif /* DEBUG */

/****** ADVANCED SETTINGS ******/

const byte reqQueueCount = 15;
const int reqQueueSize = 256; 
const byte maxSlaves = 247; 
const int modbusSize = 256; 
const byte scanCommand[] = {0x03, 0x00, 0x00, 0x00, 0x01}; 

const char *ssid = "Harish";
const char *password = "23@harish";

/****** DEFAULT FACTORY SETTINGS ******/

typedef struct
{
  byte mac[6];
  IPAddress ip;
  IPAddress subnet;
  IPAddress gateway;
  IPAddress dns;
  unsigned int tcpPort;
  unsigned int webPort;
  bool enableRtuOverTcp;
  unsigned long baud;
  unsigned int serialConfig;
  unsigned int serialTimeout;
  byte serialRetry;
} config_type;

const config_type defaultConfig = {
  { 0x90, 0xA2, 0xDA },  // mac (bytes 4, 5 and 6 will be generated randomly)
  {192, 168, 1, 254},    // ip
  {255, 255, 255, 0},    // subnet
  {192, 168, 1, 1},      // gateway
  {192, 168, 1, 1},      // dns
  502,                   // tcpPort
  80,                    // webPort
  false,                 // enableRtuOverTcp
  9600,                  // baud
  SERIAL_8N1,            // serialConfig
  500,                   // serialTimeout
  1                      // serialRetry
};
// local configuration values (stored in RAM)
config_type localConfig;

/****** ETHERNET AND SERIAL ******/

#define UDP_TX_PACKET_MAX_SIZE modbusSize
byte maxSockNum;
WiFiServer modbusServer(502);
WiFiServer webServer(80);

/****** TIMERS AND STATE MACHINE ******/

class MicroTimer {
  private:
    unsigned long timestampLastHitMs;
    unsigned long sleepTimeMs;
  public:
    boolean isOver();
    void sleep(unsigned long sleepTimeMs);
};

boolean MicroTimer::isOver() {
  if ((unsigned long)(micros() - timestampLastHitMs) > sleepTimeMs) {
    return true;
  }
  return false;
}
void MicroTimer::sleep(unsigned long sleepTimeMs) {
  this->sleepTimeMs = sleepTimeMs;
  timestampLastHitMs = micros();
}
class Timer {
  private:
    unsigned long timestampLastHitMs;
    unsigned long sleepTimeMs;
  public:
    boolean isOver();
    void sleep(unsigned long sleepTimeMs);
};
boolean Timer::isOver() {
  if ((unsigned long)(millis() - timestampLastHitMs) > sleepTimeMs) {
    return true;
  }
  return false;
}
void Timer::sleep(unsigned long sleepTimeMs) {
  this->sleepTimeMs = sleepTimeMs;
  timestampLastHitMs = millis();
}

Timer requestTimeout;
uint16_t crc;

byte scanCounter = 0;
enum state : byte
{
  IDLE, SENDING, DELAY, WAITING
};
enum state serialState;
unsigned int charTimeout;
unsigned int frameDelay;

/****** RUN TIME AND DATA COUNTERS ******/

volatile uint32_t seed1;  // seed1 is generated by CreateTrulyRandomSeed()
volatile int8_t nrot;
uint32_t seed2 = 17111989;   // seed2 is static

// store uptime seconds (includes seconds counted before millis() overflow)
unsigned long seconds;
// store last millis() so that we can detect millis() overflow
unsigned long last_milliseconds = 0;
// store seconds passed until the moment of the overflow so that we can add them to "seconds" on the next call
unsigned long remaining_seconds = 0;

unsigned long serialTxCount = 0;
unsigned long serialRxCount = 0;
unsigned long ethTxCount = 0;
unsigned long ethRxCount = 0;

/****** SETUP: RUNS ONCE ******/

void setup()
{
  CreateTrulyRandomSeed();
  localConfig = defaultConfig;
  startSerial();
  startWifi();
  dbgln(F("\n[arduino] Starting..."));
}

/****** LOOP ******/

void loop()
{
	CheckWiFiConn();
  recvWeb();
	recvTcp();
	processRequests();
	sendSerial();
	recvSerial();
	
	maintainCounters();   // maintain counters and synchronize 
	                      // their reset to zero when they overflow
	maintainUptime();    // maintain uptime in case of millis() overflow
}
